"use strict";
/**
 * rpc connection management, sending rpc messages
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleMsgAwait = exports.handleMsg = exports.init = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const define = require("../util/define");
const appUtil = __importStar(require("../util/appUtil"));
let app;
let msgHandler = {};
let rpcId = 1; // Must start from 1, not 0
let rpcRequest = {};
let rpcTimeMax = 10 * 1000; //overtime time
let outTime = 0; // Current time + timeout
/**
 * init
 * @param _app
 */
function init(_app) {
    app = _app;
    let rpcConfig = app.someconfig.rpc || {};
    let timeout = Number(rpcConfig.timeout) || 0;
    if (timeout >= 5) {
        rpcTimeMax = timeout * 1000;
    }
    outTime = Date.now() + rpcTimeMax;
    setInterval(() => {
        outTime = Date.now() + rpcTimeMax;
    }, 100);
    setInterval(checkTimeout, 3000);
    new rpc_create();
}
exports.init = init;
/**
 * Process rpc messages
 *
 *     [1]         [1]      [...]    [...]      [...]
 *   msgType    rpcBufLen   rpcBuf   msgBuf    bufLast
 */
function handleMsg(sid, bufAll) {
    let rpcBufLen = bufAll.readUInt8(1);
    let rpcMsg = JSON.parse(bufAll.slice(2, 2 + rpcBufLen).toString());
    let msg;
    if (rpcMsg.len === undefined) {
        msg = JSON.parse(bufAll.slice(2 + rpcBufLen).toString());
    }
    else {
        msg = JSON.parse(bufAll.slice(2 + rpcBufLen, bufAll.length - rpcMsg.len).toString());
        msg.push(bufAll.slice(bufAll.length - rpcMsg.len));
    }
    if (!rpcMsg.cmd) {
        let timeout = rpcRequest[rpcMsg.id];
        if (timeout) {
            delete rpcRequest[rpcMsg.id];
            timeout.cb(...msg);
        }
    }
    else {
        let cmd = rpcMsg.cmd.split('.');
        if (rpcMsg.id) {
            msg.push(getCallBackFunc(sid, rpcMsg.id));
        }
        msgHandler[cmd[0]][cmd[1]](...msg);
    }
}
exports.handleMsg = handleMsg;
function handleMsgAwait(sid, bufAll) {
    let rpcBufLen = bufAll.readUInt8(1);
    let rpcMsg = JSON.parse(bufAll.slice(2, 2 + rpcBufLen).toString());
    let msg;
    if (rpcMsg.len === undefined) {
        msg = JSON.parse(bufAll.slice(2 + rpcBufLen).toString());
    }
    else if (2 + rpcBufLen + rpcMsg.len === bufAll.length) {
        msg = bufAll.slice(bufAll.length - rpcMsg.len);
    }
    else {
        msg = JSON.parse(bufAll.slice(2 + rpcBufLen, bufAll.length - rpcMsg.len).toString());
        msg.push(bufAll.slice(bufAll.length - rpcMsg.len));
    }
    if (!rpcMsg.cmd) {
        let timeout = rpcRequest[rpcMsg.id];
        if (timeout) {
            delete rpcRequest[rpcMsg.id];
            timeout.cb(msg);
        }
    }
    else {
        let cmd = rpcMsg.cmd.split('.');
        let res = msgHandler[cmd[0]][cmd[1]](...msg);
        if (!rpcMsg.id) {
            return;
        }
        if (res && typeof res.then === "function") {
            res.then((data) => {
                cbFunc(data);
            });
        }
        else {
            cbFunc(res);
        }
        function cbFunc(data) {
            let socket = app.rpcPool.getSocket(sid);
            if (!socket) {
                return;
            }
            if (data === undefined) {
                data = null;
            }
            if (data instanceof Buffer) {
                socket.send(getRpcMsg({ "id": rpcMsg.id }, Buffer.allocUnsafe(0), data, 7 /* rpcMsgAwait */));
            }
            else if (data instanceof Array && data[data.length - 1] instanceof Buffer) {
                let tmpRes = [...data];
                let buf = tmpRes.pop();
                socket.send(getRpcMsg({ "id": rpcMsg.id }, Buffer.from(JSON.stringify(tmpRes)), buf, 7 /* rpcMsgAwait */));
            }
            else {
                socket.send(getRpcMsg({ "id": rpcMsg.id }, Buffer.from(JSON.stringify(data)), null, 7 /* rpcMsgAwait */));
            }
        }
    }
}
exports.handleMsgAwait = handleMsgAwait;
/**
 * rpc structure
 */
class rpc_create {
    constructor() {
        this.toId = "";
        this.notify = false;
        this.rpcObj = {};
        this.rpcObjAwait = {};
        this.loadRemoteMethod();
    }
    loadRemoteMethod() {
        let self = this;
        app.rpc = this.rpcFunc.bind(this);
        app.rpcAwait = this.rpcFuncAwait.bind(this);
        let tmp_rpc_obj = this.rpcObj;
        let tmp_rpc_obj_await = this.rpcObjAwait;
        let dirName = path.join(app.base, define.some_config.File_Dir.Servers);
        let exists = fs.existsSync(dirName);
        if (!exists) {
            return;
        }
        let thisSvrHandler = [];
        fs.readdirSync(dirName).forEach(function (serverName) {
            let needRpc = !app.noRpcMatrix[appUtil.getNoRpcKey(app.serverType, serverName)];
            if (!needRpc && serverName !== app.serverType) {
                return;
            }
            let remoteDirName = path.join(dirName, serverName, '/remote');
            let exists = fs.existsSync(remoteDirName);
            if (exists) {
                if (needRpc) {
                    tmp_rpc_obj[serverName] = {};
                    tmp_rpc_obj_await[serverName] = {};
                }
                fs.readdirSync(remoteDirName).forEach(function (fileName) {
                    if (!fileName.endsWith(".js")) {
                        return;
                    }
                    let fileBasename = path.basename(fileName, '.js');
                    let remote = require(path.join(remoteDirName, fileName));
                    if (remote.default && typeof remote.default === "function") {
                        if (needRpc) {
                            tmp_rpc_obj[serverName][fileBasename] = self.initFunc(serverName, fileBasename, remote.default.prototype, Object.getOwnPropertyNames(remote.default.prototype));
                            tmp_rpc_obj_await[serverName][fileBasename] = self.initFuncAwait(serverName, fileBasename, remote.default.prototype, Object.getOwnPropertyNames(remote.default.prototype));
                        }
                        if (serverName === app.serverType) {
                            thisSvrHandler.push({ "filename": fileBasename, "con": remote.default });
                        }
                    }
                });
            }
        });
        for (let one of thisSvrHandler) {
            msgHandler[one.filename] = new one.con(app);
        }
    }
    rpcFunc(serverId) {
        this.toId = serverId;
        return this.rpcObj;
    }
    rpcFuncAwait(serverId, notify = false) {
        this.toId = serverId;
        this.notify = notify;
        return this.rpcObjAwait;
    }
    initFunc(serverType, filename, func, funcFields) {
        let res = {};
        for (let field of funcFields) {
            if (field !== "constructor" && typeof func[field] === "function") {
                res[field] = this.proxyCb({ "serverType": serverType, "file_method": filename + "." + field });
            }
        }
        return res;
    }
    initFuncAwait(serverType, filename, func, funcFields) {
        let res = {};
        for (let field of funcFields) {
            if (field !== "constructor" && typeof func[field] === "function") {
                res[field] = this.proxyCbAwait({ "serverType": serverType, "file_method": filename + "." + field });
            }
        }
        return res;
    }
    proxyCb(cmd) {
        let self = this;
        let func = function (...args) {
            self.send(self.toId, cmd, args);
        };
        return func;
    }
    proxyCbAwait(cmd) {
        let self = this;
        let func = function (...args) {
            return self.sendAwait(self.toId, self.notify, cmd, args);
        };
        return func;
    }
    send(sid, cmd, args) {
        if (sid === "*") {
            this.sendT(cmd, args);
            return;
        }
        let cb = null;
        if (typeof args[args.length - 1] === "function") {
            cb = args.pop();
        }
        let bufLast = null;
        if (args[args.length - 1] instanceof Buffer) {
            bufLast = args.pop();
        }
        if (sid === app.serverId) {
            sendRpcMsgToSelf(cmd, Buffer.from(JSON.stringify(args)), bufLast, cb);
            return;
        }
        let socket = app.rpcPool.getSocket(sid);
        if (!socket) {
            if (cb) {
                process.nextTick(() => {
                    cb(1 /* noServer */);
                });
            }
            return;
        }
        let rpcMsg = {
            "cmd": cmd.file_method
        };
        if (cb) {
            let id = getRpcId();
            rpcRequest[id] = { "cb": cb, "time": outTime, "await": false };
            rpcMsg.id = id;
        }
        socket.send(getRpcMsg(rpcMsg, Buffer.from(JSON.stringify(args)), bufLast, 6 /* rpcMsg */));
    }
    sendT(cmd, args) {
        let servers = app.getServersByType(cmd.serverType);
        if (servers.length === 0) {
            return;
        }
        let bufLast = null;
        if (args[args.length - 1] instanceof Buffer) {
            bufLast = args.pop();
        }
        let msgBuf = Buffer.from(JSON.stringify(args));
        let bufEnd = getRpcMsg({ "cmd": cmd.file_method }, msgBuf, bufLast, 6 /* rpcMsg */);
        for (let one of servers) {
            if (one.id === app.serverId) {
                sendRpcMsgToSelf(cmd, msgBuf, bufLast);
            }
            else {
                let socket = app.rpcPool.getSocket(one.id);
                socket && socket.send(bufEnd);
            }
        }
    }
    sendAwait(sid, notify, cmd, args) {
        if (sid === "*") {
            this.sendTAwait(cmd, args);
            return undefined;
        }
        let bufLast = null;
        if (args[args.length - 1] instanceof Buffer) {
            bufLast = args.pop();
        }
        if (sid === app.serverId) {
            return sendRpcMsgToSelfAwait(cmd, Buffer.from(JSON.stringify(args)), bufLast, notify);
        }
        let socket = app.rpcPool.getSocket(sid);
        if (!socket) {
            return undefined;
        }
        let rpcMsg = {
            "cmd": cmd.file_method
        };
        let promise = undefined;
        if (!notify) {
            let cb = null;
            promise = new Promise((resolve) => {
                cb = resolve;
            });
            let id = getRpcId();
            rpcRequest[id] = { "cb": cb, "time": outTime, "await": true };
            rpcMsg.id = id;
        }
        socket.send(getRpcMsg(rpcMsg, Buffer.from(JSON.stringify(args)), bufLast, 7 /* rpcMsgAwait */));
        return promise;
    }
    sendTAwait(cmd, args) {
        let servers = app.getServersByType(cmd.serverType);
        if (servers.length === 0) {
            return;
        }
        let bufLast = null;
        if (args[args.length - 1] instanceof Buffer) {
            bufLast = args.pop();
        }
        let msgBuf = Buffer.from(JSON.stringify(args));
        let bufEnd = getRpcMsg({ "cmd": cmd.file_method }, msgBuf, bufLast, 7 /* rpcMsgAwait */);
        for (let one of servers) {
            if (one.id === app.serverId) {
                sendRpcMsgToSelfAwait(cmd, msgBuf, bufLast, true);
            }
            else {
                let socket = app.rpcPool.getSocket(one.id);
                socket && socket.send(bufEnd);
            }
        }
    }
}
/**
 * Get rpcId
 */
function getRpcId() {
    let id = rpcId++;
    if (rpcId > 9999999) {
        rpcId = 1;
    }
    return id;
}
/**
 * rpc timeout detection
 */
function checkTimeout() {
    let now = Date.now();
    for (let id in rpcRequest) {
        if (rpcRequest[id].time < now) {
            let one = rpcRequest[id];
            delete rpcRequest[id];
            one.await ? one.cb(undefined) : one.cb(2 /* timeout */);
        }
    }
}
/**
 *  Send rpc message
 *
 *    [4]       [1]         [1]      [...]    [...]      [...]
 *  allMsgLen  msgType   rpcBufLen   rpcBuf   msgBuf    bufLast
 */
function getRpcMsg(rpcMsg, msgBuf, bufLast, t) {
    let buffLastLen = 0;
    if (bufLast) {
        buffLastLen = bufLast.length;
        rpcMsg.len = buffLastLen;
    }
    let rpcBuf = Buffer.from(JSON.stringify(rpcMsg));
    let buffEnd = Buffer.allocUnsafe(6 + rpcBuf.length + msgBuf.length + buffLastLen);
    buffEnd.writeUInt32BE(buffEnd.length - 4, 0);
    buffEnd.writeUInt8(t, 4);
    buffEnd.writeUInt8(rpcBuf.length, 5);
    rpcBuf.copy(buffEnd, 6);
    msgBuf.copy(buffEnd, 6 + rpcBuf.length);
    if (bufLast) {
        bufLast.copy(buffEnd, buffEnd.length - buffLastLen);
    }
    return buffEnd;
}
/**
 * Send rpc message to this server
 */
function sendRpcMsgToSelf(cmd, msgBuf, bufLast, cb) {
    let args = JSON.parse(msgBuf.toString());
    if (bufLast) {
        args.push(bufLast);
    }
    if (cb) {
        let id = getRpcId();
        rpcRequest[id] = { "cb": cb, "time": outTime, "await": false };
        args.push(getCallBackFuncSelf(id));
    }
    process.nextTick(() => {
        let route = cmd.file_method.split('.');
        let file = msgHandler[route[0]];
        file[route[1]].apply(file, args);
    });
}
/**
 * Send rpc message to this server await
 */
function sendRpcMsgToSelfAwait(cmd, msgBuf, bufLast, notify) {
    let args = JSON.parse(msgBuf.toString());
    if (bufLast) {
        args.push(bufLast);
    }
    if (notify) {
        process.nextTick(() => {
            let route = cmd.file_method.split('.');
            let file = msgHandler[route[0]];
            file[route[1]].apply(file, args);
        });
        return undefined;
    }
    let cb = null;
    let promise = new Promise((resolve) => {
        cb = resolve;
    });
    let id = getRpcId();
    rpcRequest[id] = { "cb": cb, "time": outTime, "await": true };
    process.nextTick(() => {
        let route = cmd.file_method.split('.');
        let file = msgHandler[route[0]];
        let res = file[route[1]].apply(file, args);
        if (res && typeof res.then === "function") {
            res.then((data) => {
                cbFunc(data);
            });
        }
        else {
            cbFunc(res);
        }
        function cbFunc(data) {
            let timeout = rpcRequest[id];
            if (!timeout) {
                return;
            }
            delete rpcRequest[id];
            if (data === undefined) {
                data = null;
            }
            if (data instanceof Buffer) {
                timeout.cb(data);
            }
            else if (data instanceof Array && data[data.length - 1] instanceof Buffer) {
                let tmpRes = [...data];
                let buf = tmpRes.pop();
                tmpRes = JSON.parse(JSON.stringify(tmpRes));
                tmpRes.push(buf);
                timeout.cb(tmpRes);
            }
            else {
                timeout.cb(JSON.parse(JSON.stringify(data)));
            }
        }
    });
    return promise;
}
/**
 * rpc callback
 */
function getCallBackFunc(sid, id) {
    return function (...args) {
        let bufLast = null;
        if (args[args.length - 1] instanceof Buffer) {
            bufLast = args.pop();
        }
        let socket = app.rpcPool.getSocket(sid);
        if (socket) {
            socket.send(getRpcMsg({ "id": id }, Buffer.from(JSON.stringify(args)), bufLast, 6 /* rpcMsg */));
        }
    };
}
/**
 * rpc server callback
 */
function getCallBackFuncSelf(id) {
    return function (...args) {
        let buf = null;
        if (args[args.length - 1] instanceof Buffer) {
            buf = args.pop();
        }
        args = JSON.parse(JSON.stringify(args));
        if (buf) {
            args.push(buf);
        }
        process.nextTick(() => {
            let timeout = rpcRequest[id];
            if (timeout) {
                delete rpcRequest[id];
                timeout.cb.apply(null, args);
            }
        });
    };
}
